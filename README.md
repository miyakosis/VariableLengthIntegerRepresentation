Variable-length integer representation  
====  
可変長のバイト配列での数値表現を提供するライブラリ (Java)  

## Description  
一般に数値を扱う際は int や long を用い、Long.MAX_VALUE を超える数値を扱う場合は java.math.BigInteger を用います。  
しかしファイルフォーマットや通信プロトコルなどにおいて「できるだけ少ないバイトで数値を表現したい」「どのくらい大きい数値を取り扱うか決められない」という相反する要求が求められることがあります。  
java.math.BigInteger による可変長バイトによる表現は、数値自体は短いバイト数で表現できますが、「データが何バイトか」という情報もまた同時に記録する必要があります。  

そこで Variable-length integer representation は、数値をできるだけ少ないバイト数で表現する可変長整数表現の変換を提供します。  

Variable-length integer representation は以下の3通りの表現方式を用いて、数値からバイト配列への変換および逆変換を提供します。  
- 符号なし可変長整数  
- 符号つき可変長整数  
- 符号つき0近傍最適化可変長整数  


### 数値表現の比較  
|| 符号なし可変長整数 | 符号つき可変長整数 | 符号つき0近傍最適化可変長整数 |
|:---|:---|:---|:---|
| 1バイトで表現できる範囲 | 0 ～ 127 | -64 ～ 63 | -107 ～ 107 |
| 2バイトで表現できる範囲 | 0 ～ 16383 | -8192 ～ 8191 | -1024 ～ 1023 |
| 3バイトで表現できる範囲 | 0 ～ 2097151 | -1048576 ～ 1048575 | -1048576 ～ 1048575 |

符号なし0近傍最適化可変長整数 についても検討しましたが、符号なし可変長整数 より狭い範囲しか表現できないことが多く、有用性がほぼ無いと考え実装しません。  


## 数値表現の詳細  
### 符号なし可変長整数  

BigEndian で可変長の複数バイトを使って正の数値を表現します。  
8bit のうち、MSBを継続ビットとして使用し、MSBを除く7bitで数値を表します。  
次に続く byte は、継続ビットを 1、終端の byte は継続ビットを 0 とします。  
(末端の継続ビットを 0 とするのは、「数値が 0-127 の場合にビット操作が不要である」を想定していましたが、実装上結局ビット演算が必要になったこと、符号拡張を考慮するとMSBが0のデータの方が扱いやすいことから、逆がよかったかもしれません)  

例：  
数値 可変長数値表現  
0(0000 0000) <-> [0000 0000]  
127(0111 1111) <-> [0111 1111]  
128(1000 0000) <-> [1000 0001, 0000 0000]  
129(1000 0001) <-> [1000 0001, 0000 0001]  
16383(0011 1111, 1111 1111) <-> [1111 1111, 0111 1111]  
16384(0100 0000, 0000 0000) <-> [1000 0001, 1000 0000, 0000 0000]  
2147483647(0x7FFFFFFF) <-> [1000 0111, 1111 1111, 1111 1111, 1111 1111, 0111 1111]  
2147483648(0x80000000) <-> [1000 1000, 1000 0000, 1000 0000, 1000 0000, 0000 0000]  


### 符号つき可変長整数  

BigEndian で可変長の複数バイトを使って数値を表現します。  
8bit のうち、MSBを継続ビットとして使用し、MSBを除く7bitで2の補数表現で数値を表します。  
次に続く byte は、継続ビットを 1、終端の byte は継続ビットを 0 とします。  


例：  
数値 可変長数値表現  
0(0000 0000) <-> [0000 0000]  
63(0011 1111) <-> [0011 1111]  
64(0100 0000) <-> [1000 0000, 0100 0000]  
127(0111 1111) <-> [1000 0000, 0111 1111]  
128(1000 0000) <-> [1000 0001, 0000 0000]  
8191(0001 1111, 1111 1111) <-> [1011 1111, 0111 1111]  
8192(0010 0000, 0000 0000) <-> [1000 0000, 1100 0000, 0000 0000]  
2147483647(0x7FFFFFFF) <-> [1000 0111, 1111 1111, 1111 1111, 1111 1111, 0111 1111]  
2147483648(0x80000000) <-> [1000 1000, 1000 0000, 1000 0000, 1000 0000, 0000 0000]  
-1(1111 1111) <-> [0111 1111]  
-64(1100 0000) <-> [0100 0000]  
-65(1011 1111) <-> [1111 1111, 0011 1111]  
-127(1000 0001) <-> [1111 1111, 0000 0001]  
-128(1000 0000) <-> [1111 1111, 0000 0000]  
-129(1111 1111, 0111 1111) <-> [1111 1110, 0111 1111]  
-8192(1110 0000, 0000 0000) <-> [1100 0000, 0000 0000]  
-8193(1101 1111, 1111 1111) <-> [1111 1111, 1011 1111, 0111 1111]  
-2147483648(0x80000000) <-> [1111 1000, 1000 0000, 1000 0000, 1000 0000, 0000 0000]  
-2147483649(0xFF7FFFFFFF) <-> [1111 0111, 1111 1111, 1111 1111, 1111 1111, 0111 1111]  

##### 符号バイトについて
+64 と -64 は 終端バイトの表現が同じになります。  
先頭バイトの MSB+1 のビットが符号ビットとなるため、[0100 0000] は単体では負数として判断されます。  
そのため +64 を表現するためには符号ビットを保持するための [1000 0000] という符号バイトが必要となります。-128 と 0 も同様です。  
まとめると、正の数を可変長数値表現した際に先頭バイトの MSB+1 のビットが1、あるいは負の数を可変長数値表現した際に先頭バイトの MSB+1 のビットが0になるとき、符号を表現する1バイトが必要になります。  


### 符号つき0近傍最適化可変長整数  
上記符号つき可変長整数では、1バイトで -64～+63 の値が表現できます。  
しかし10進数での取り扱いを考えると、1バイトで 0～100 を扱えた方が利便性が高そうです。  
そこで UTF-8 エンコーディングのように、先頭バイトが-100～100であればその値、それ以外であれば可変長整数であるとする数値表現を検討しました。  
(2バイト、3バイトでの数値表現を検討した結果、1バイトで 107～-107 が表現できます)  

先頭バイトと続くバイトの数値表現  
127～112 : 3バイトで数値表現する。(127-112 = 16個(両端含む) = 4bit, 4bit + 8bit + 8bit = 20bit = 1048576)  
111～108 : 2バイトで数値表現する。(111-108 = 4個(両端含む) = 2bit, 2bit + 8bit = 10bit = 1024)  
107～-107 : その値  
-108～-111 : 2バイトで数値表現する。  
-112～-127 : 3バイトで数値表現する。  
-128 (0x80): 次のバイト以降に符号つき可変長整数で表現する。  

これにより、バイト数で表現できる数値の範囲は以下の通りになる  
1バイト：-107 ～ 107  
2バイト：-1024 ～ 1023  
3バイト：-1048576 ～ 1048575  
Nバイト：(N * 7 / 8) bit で表現できる数  

##### 2 バイトによる数値表現について
数値の1バイト目が符号つき0近傍最適化可変長整数表現の先頭バイトの値で決まり、数値の2バイト目はそのまま保持します。  
たとえば 200[0000 0000, 1100 1000] は、数値の1バイト目が 0x00 ですので、符号つき0近傍最適化可変長整数表現は 108 [0110 1100]、  
2バイト目は数値の2バイト目[1100 1000]を保持します。  
つまり 255 を符号つき0近傍最適化可変長整数表現で表すと [0110 1100, 1100 1000]となります。  
同様に 456 [0000 0001, 1100 1000] は符号つき0近傍最適化可変長整数表現で表すと [0110 1101, 1100 1000]となります。  

数値の1バイト目と符号つき0近傍最適化可変長整数表現の1バイト目の対応は以下の通りです。  
0x00 <-> 108  
0x01 <-> 109  
0x02 <-> 110  
0x03 <-> 111  

負の数も同様に、以下の対応となります。  
0xFF <-> -108  
0xFE <-> -109  
0xFD <-> -110  
0xFC <-> -111  

(3バイトによる数値表現も同様に、1バイト目が数値の1バイト目により決定し、2,3バイト目に数値の2バイト目、3バイト目の値が設定されます)  


例：  
数値 バイト配列表現  
107(0110 1011) <-> [0110 1011]  
108(0110 1100) <-> [0110 1100, 0110 1100]				(※先頭バイト：108)  
109(0110 1101) <-> [0110 1100, 0110 1101]  
255(0000 0000, 1111 1111) <-> [0110 1100, 1111 1111]  
256(0000 0001, 0000 0000) <-> [0110 1101, 0000 0000]	(※先頭バイト：109)  
511(0000 0001, 1111 1111) <-> [0110 1101, 1111 1111]  
512(0000 0010, 0000 0000) <-> [0110 1110, 0000 0000]	(※先頭バイト：110)  
767(0000 0010, 1111 1111) <-> [0110 1110, 1111 1111]  
768(0000 0011, 0000 0000) <-> [0110 1111, 0000 0000]	(※先頭バイト：111)  
1023(0000 0011, 1111 1111) <-> [0110 1111, 1111 1111]	  
1024(0000 0100, 0000 0000) <-> [0111 0000, 0000 0100, 0000 0000]	(※先頭バイト：112)  
1048575(0000 1111, 1111 1111, 1111 1111) <-> [0111 1111, 1111 1111, 1111 1111]	(※先頭バイト：127)  
1048576(0001 0000, 0000 0000, 0000 0000) <-> [1000 0000, 1100 0000, 1000 0000, 0000 0000]  
-1(1111 1111) <-> [1111 1111]  
-107(1001 0101) <-> [1001 0101]  
-108(1001 0100) <-> [1001 0100, 1001 0100]				(※先頭バイト：-108)  
-127(1000 0001) <-> [1001 0100, 1000 0001]  
-128(1000 0000) <-> [1001 0100, 1000 0000]  
-129(1111 1111, 0111 1111) <-> [1001 0100, 0111 1111]	  
-256(1111 1111, 0000 0000) <-> [1001 0100, 0000 0000]	  
-257(1111 1110, 1111 1111) <-> [1001 0011, 1111 1111]	(※先頭バイト：-109)  
-1024(1111 1100, 0000 0000) <-> [1001 0001, 0000 0000]	(※先頭バイト：-111)  
-1025(1111 1011, 1111 1111) <-> [1001 0000, 1111 1011, 1111 1111]	(※先頭バイト：-112)  
-1024(1111 1100, 0000 0000) <-> [1001 0001, 0000 0000]	  
-1048576(1111 0000, 0000 0000, 0000 0000) <-> [1000 0001, 0000 0000, 0000 0000]	(※先頭バイト：-127)  
-1048577(1110 1111, 1111 1111, 1111 1111) <-> [1000 0000, 1111 1111, 1011 1111, 1111 1111, 0111 1111]  


##### 冗長表現について  
たとえば 100 は [0110 0100] という1バイト表現の他、[0110 1100, 0110 0100](※先頭バイト：108) という2バイトや [0111 1111, 1000 0000, 0110 0100] という3バイトでの冗長な表現も可能です。  
ただし実用上大きな問題はないはずです。  



## Licence  
このコードは無保証です。  
商用・非商用問わず、あなたのソフトウェアに組み込むことができます。  
ソースコードの一部分や全体をコピーして組み込むこともできます。  
